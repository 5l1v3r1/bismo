// Copyright (c) 2018 Xilinx
//
// BSD v3 License
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of [project] nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include <iostream>
#include <vector>
#include <cassert>
#include <time.h>
#include <ap_int.h>
#include "platform.h"
#include "EmuTestFetchInstrGen.hpp"
#include "BISMOInstruction.hpp"
#include "InstrGen.hpp"
#include "StageModels.hpp"
#include "gemmbitserial/test/testhelpers.hpp"
#include "gemmbitserial/gemmbitserial.hpp"

using namespace std;

WrapperRegDriver * p;
EmuTestFetchInstrGen * t;

// write a descriptor into the instruction generator
void writeDescriptor(SingleMMDescriptor desc) {
  // this function will need adjustments if
  // BISMO_MMDESCR_BITS changes. mark tested value:
  assert(BISMO_MMDESCR_BITS == 208);
  while(t->get_in_ready() != 1);
  const ap_uint<BISMO_MMDESCR_BITS> raw = desc.asRaw();
  t->set_in_bits6(raw(31, 0));
  t->set_in_bits5(raw(63, 32));
  t->set_in_bits4(raw(95, 64));
  t->set_in_bits3(raw(127, 96));
  t->set_in_bits2(raw(159, 128));
  t->set_in_bits1(raw(191, 160));
  t->set_in_bits0(raw(207, 192));

  t->set_in_valid(1);
  t->set_in_valid(0);
}

// read a single instruction from the queue as generated by the
// instruction generator
BISMOInstruction readInstr() {
  std::vector<unsigned int> rinds = t->getStatusRegs()["out_bits"];
  while(t->get_out_valid() != 1);
  BISMOInstruction ins_read;
  for(int r = 0; r < BISMO_INSTR_BITS/32; r++) {
    ins_read(32*(r+1)-1, 32*r) = p->readReg(rinds[r]);
  }
  t->set_out_ready(0);
  t->set_out_ready(1);
  return ins_read;
}

int main(int argc, char const *argv[]) {
  bool t_okay = true;
  try {
    cout << "EmuTestFetchInstrGen running" << endl;
    cout << "Template parameters used for HLS hardware:";
    cout << " M = " << TEMPLATE_PARAM_M;
    cout << " K = " << TEMPLATE_PARAM_K;
    cout << " N = " << TEMPLATE_PARAM_N;
    cout << " ETF_S = " << TEMPLATE_PARAM_ETF_S;
    cout << endl;

    srand(time(NULL));

    // hardware dims for test
    const size_t Dm = 2, Dk = 4, Dn = 2;
    // define dimensions for the workload
    const size_t tiles_m = 1;
    const size_t tiles_k = 1;
    const size_t tiles_n = 1;
    const size_t bits_l = 1;
    const size_t bits_r = 1;
    const size_t base_l = 0;
    const size_t base_r = 0;
    const size_t base_res = 0;
    const size_t nbufs_res = tiles_m * tiles_n;
    const size_t nrows_lhs = Dm * tiles_m;
    const size_t nrows_rhs = Dn * tiles_n;
    const size_t ncols = Dk * tiles_k;
    const size_t mem_m = tiles_m * tiles_k * bits_l;
    const size_t mem_n = tiles_n * tiles_k * bits_r;
    const bool sgn_lhs = true;
    const bool sgn_rhs = true;


    std::vector<BISMOInstruction> instrs;
    SingleMMDescriptor dsc;
    // define workload shape
    dsc.tiles_m = tiles_m;
    dsc.tiles_k = tiles_k;
    dsc.tiles_n = tiles_n;
    dsc.bits_l = bits_l;
    dsc.bits_r = bits_r;
    dsc.signed_l = sgn_lhs;
    dsc.signed_r = sgn_rhs;
    dsc.base_l = base_l;
    dsc.base_r = base_r;
    dsc.base_res = base_res;
    dsc.nbufs_res = nbufs_res;
    dsc.dram_lhs = 0;
    dsc.dram_rhs = 0x1000;
    // create golden fetch instr sequence in software
    InstrGen::FetchInstrGenSingleMM<
      TEMPLATE_PARAM_M, TEMPLATE_PARAM_K, TEMPLATE_PARAM_N, TEMPLATE_PARAM_ETF_S
    >(dsc, instrs);

    p = initPlatform();
    t = new EmuTestFetchInstrGen(p);

    // give the descriptor to the instruction generator
    writeDescriptor(dsc);
    // read and compare generated instructions
    for(auto & i : instrs) {
      BISMOInstruction ins_gen = readInstr();
      bool ok = (ins_gen == i);
      t_okay &= ok;
      cout << "Equal? " << ok << endl;
      if(!ok) {
        cout << "Expected: " << i << endl;
        cout << "Found: " << ins_gen << endl;
      }
    }

    delete t;
    deinitPlatform(p);
  } catch(const char * e) {
    cout << "Exception: " << e << endl;
  }

  cout << "Test passed: " << (t_okay ? "yes" : "no") << endl;

  return t_okay ? 0 : -1;
}
