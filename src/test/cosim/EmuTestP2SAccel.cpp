// Author:  Davide Conficconi
// Date: 19/10/2018
// Revision: 0


#include <cassert>
#include <iostream>
#include <vector>
#include "platform.h"
#include "EmuTestP2SAccel.hpp"
#include "gemmbitserial/gemmbitserial.hpp"
#include "gemmbitserial/test/testhelpers.hpp"

using namespace std;
using namespace gemmbitserial;

#define P2S_ALIGN 64
// TODO Yaman: consider exposing from generated header file
#define MAX_ACCEL_BITWIDTH 8

WrapperRegDriver * p;
EmuTestP2SAccel * dut;

uint32_t exec_and_wait() {
  dut->set_enable(1);
  dut->set_ackqueue_ready(false);
  while(dut->get_ackqueue_valid() != 1);
  uint32_t ret = dut->get_ackqueue_bits();
  // pulse ackqueue.ready to consume ack token
  dut->set_ackqueue_ready(true);
  dut->set_ackqueue_ready(false);
  dut->set_enable(0);
  return ret;
}

void setup_p2s(
  void * accel_buf_src,
  uint32_t nbytes,
  void * accel_buf_dst,
  uint32_t rows,
  uint32_t cols,
  uint32_t bit_width
) {
  // ensure #cols is divisible by P2S_ALIGN
  assert(cols % P2S_ALIGN == 0);
  size_t col_groups = cols / P2S_ALIGN;
  dut->set_cmdqueue_valid(false);
  dut->set_cmdqueue_bits_dramBaseAddrSrc((AccelDblReg) accel_buf_src);
  // cout << "[SW] DRAM Base Addr Src" << accel_buf << endl;
  dut->set_cmdqueue_bits_dramBaseAddrDst((AccelDblReg) accel_buf_dst );
  dut->set_cmdqueue_bits_matrixRows(rows);
  dut->set_cmdqueue_bits_matrixColsGroup(col_groups);
  dut->set_cmdqueue_bits_actualPrecision(bit_width);
  dut->set_cmdqueue_bits_waitCompleteBytes(nbytes);
  // wait until cmdqueue is available
  while(dut->get_cmdqueue_ready() != 1);
  // pulse cmdqueue.valid
  dut->set_cmdqueue_valid(true);
  dut->set_cmdqueue_valid(false);
}

int main()
{
  bool all_OK = true;
  p = initPlatform();
  dut = new EmuTestP2SAccel(p);
  vector<size_t> test_colgroups {1, 2, 3};
  vector<size_t> test_rows {1, 2, 3};
  vector<size_t> test_bits {1, 2, 3};
  // required to be able to compute golden vectors with gemmbitserial
  assert(P2S_ALIGN % 64 == 0);
  // TODO check that max bit precision is set to 8 for the HW,
  // test code assumes this (the bit-parallel elem type is uint8_t)

  for(auto & colgroups : test_colgroups) {
    for(auto & rows : test_rows) {
      for(auto & bits : test_bits) {
        size_t cols = colgroups * P2S_ALIGN;
        BitSerialMatrix bsm = BitSerialMatrix::alloc(
          bits, rows, cols, false, 1, P2S_ALIGN
        );
        cout << "Now running test: ";
        bsm.printSummary();
        // requested col count is already divisible by alignment
        // so #aligned cols should be the same as #cols
        assert(bsm.ncols_a == cols);
        uint8_t * bpm = new uint8_t[rows * cols];
        // generate a random matrix of desired shape and bits
        generateRandomVector(bits, rows * cols, bpm);
        // convert to bit-serial format in software
        bsm.importRegular(bpm);
        // now do the same in hardware
        // compute buffer sizes
        size_t nbytes_bitpar = rows * cols * sizeof(uint8_t);
        size_t nbytes_bitser = (bits * rows * cols) / 8;
        // we'll memcmp the SW and HW results, so buffers must be exactly the
        // same size
        assert(sizeof(uint64_t) * bsm.wordsPerBitplane() * bits == nbytes_bitser);
        void * hw_src = p->allocAccelBuffer(nbytes_bitpar);
        void * hw_dst = p->allocAccelBuffer(nbytes_bitser);
        // set up inputs to accelerator and launch
        p->copyBufferHostToAccel(bpm, hw_src, nbytes_bitpar);
        setup_p2s(hw_src, nbytes_bitser, hw_dst, rows, cols, bits);
        uint32_t cycles = exec_and_wait();
        cout << "Took " << cycles << " clock cycles" << endl;
        // copy bit-serial matrix generated by hardware to host and compare
        uint8_t * hw_res = new uint8_t[nbytes_bitser];
        p->copyBufferAccelToHost(hw_dst, hw_res, nbytes_bitser);
        int memcmpres = memcmp(hw_res, bsm.data, nbytes_bitser);
        cout << "memcmp result " << memcmpres << endl;
        if(memcmpres != 0) {
          cout << "expected: " << endl;
          bsm.printHex();
          cout << "found: " << endl;
          memcpy(bsm.data, hw_res, nbytes_bitser);
          bsm.printHex();
        }
        all_OK &= (memcmpres == 0);
        delete [] bpm;
        delete [] hw_res;
        p->deallocAccelBuffer(hw_src);
        p->deallocAccelBuffer(hw_dst);
      }
    }
  }

  delete dut;
  deinitPlatform(p);

  if(all_OK) {
    cout << "All tests passed" << endl;
  } else {
    cout << "Some tests failed" << endl;
  }

  return all_OK ? 0 : -1;
}
